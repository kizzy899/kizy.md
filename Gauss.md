---
timezone: Asia/Shanghai
---

> 请在上边的 timezone 添加你的当地时区，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区
> 时区请参考以下列表，请移除 # 以后的内容

timezone: Pacific/Honolulu # 夏威夷-阿留申标准时间 (UTC-10)

timezone: America/Anchorage # 阿拉斯加标准时间 (UTC-9)

timezone: America/Los_Angeles # 太平洋标准时间 (UTC-8)

timezone: America/Denver # 山地标准时间 (UTC-7)

timezone: America/Chicago # 中部标准时间 (UTC-6)

timezone: America/New_York # 东部标准时间 (UTC-5)

timezone: America/Halifax # 大西洋标准时间 (UTC-4)

timezone: America/St_Johns # 纽芬兰标准时间 (UTC-3:30)

timezone: America/Sao_Paulo # 巴西利亚时间 (UTC-3)

timezone: Atlantic/Azores # 亚速尔群岛时间 (UTC-1)

timezone: Europe/London # 格林威治标准时间 (UTC+0)

timezone: Europe/Berlin # 中欧标准时间 (UTC+1)

timezone: Europe/Helsinki # 东欧标准时间 (UTC+2)

timezone: Europe/Moscow # 莫斯科标准时间 (UTC+3)

timezone: Asia/Dubai # 海湾标准时间 (UTC+4)

timezone: Asia/Kolkata # 印度标准时间 (UTC+5:30)

timezone: Asia/Dhaka # 孟加拉国标准时间 (UTC+6)

timezone: Asia/Bangkok # 中南半岛时间 (UTC+7)

timezone: Asia/Shanghai # 中国标准时间 (UTC+8)

timezone: Asia/Tokyo # 日本标准时间 (UTC+9)

timezone: Australia/Sydney # 澳大利亚东部标准时间 (UTC+10)

timezone: Pacific/Auckland # 新西兰标准时间 (UTC+12)

---

# {你的名字}

1. 自我介绍

我是gauss，希望通过本次共学能学习到更多关于web3的知识
   
2. 你认为你会完成本次残酷学习吗？

我会尽力的:D

## Notes

<!-- Content_START -->

### 2024.09.07

**Aptos区块链概述**

Aptos区块链使用拜占庭容错（BFT）共识协议，验证节点通过该协议就已完成的交易和其执行结果达成一致。验证节点决定哪些交易将被添加到区块链以及其顺序，并在本地维护最新的区块链状态。

验证节点在一个私有网络中直接相互通信，而完整节点则充当已确认交易历史的外部验证或传播资源。完整节点可重新执行交易以验证其正确性，并在发现问题时提供证据，防止验证节点的腐败或串通。

AptosBFT共识协议能够容忍最多三分之一的恶意验证节点。

验证节点的主要组件
- Mempool：一个存储尚未达成共识或执行的交易的内存缓冲区。通过mempool，各节点间可以共享这些待处理的交易。mempool还负责验证新交易的合法性，并防止拒绝服务攻击（DOS）。
- 共识（Consensus）：负责在网络中各验证节点之间达成共识，确定交易块的排序并就执行结果达成一致。临时成为领导者的验证节点从mempool中提取交易，提出新的交易块，并广播给其他验证节点。
- 执行（Execution）：负责协调交易块的执行并维护暂时状态，直到共识达成并提交块到分布式数据库。执行组件与虚拟机协作，以确保交易的执行。
- 虚拟机（VM）：运行每笔交易中的Move程序，决定执行结果。mempool使用虚拟机进行交易的初步验证，而执行组件使用虚拟机来实际执行交易。
- 存储（Storage）：用于将达成共识的交易块及其执行结果持久化到本地数据库。
- 状态同步器（State Synchronizer）：确保节点能够“追赶”区块链的最新状态并保持最新。

### 2024.09.08

在Aptos区块链中，账户代表对一组资产（如链上货币和NFT）的访问控制。这些资产由Move语言中的一种原语（称为资源）表示，强调了访问控制和稀缺性。

**账户类型和特点**

标准账户：对应于一个地址和公钥/私钥对的普通账户。

资源账户：不与任何私钥相关的自主账户，用于开发者存储资源或发布链上模块。

对象：在单一地址内存储的一组复杂资源，表示单个实体。

Aptos中的账户是显式的，需要在执行交易之前被创建。

账户创建可以通过显式调用或通过向账户地址转入Aptos代币（APT）进行隐式创建。

**账户的独特功能**

旋转认证密钥：账户的认证密钥可以更改为由不同的私钥控制，类似于Web2世界中的更改密码。

原生多重签名支持：支持k-of-n多重签名，使用Ed25519和Secp256k1 ECDSA签名方案。

**账户地址**

Aptos中的账户地址是32字节的十六进制字符串，通常显示为64个十六进制字符。

支持使用Aptos Name Service来获取.apt域名，使账户更易于识别和记忆。

**创建账户的步骤**

选择认证方案（如Ed25519或Secp256k1 ECDSA）。

生成新的私钥和公钥对。

将公钥与认证方案结合生成32字节的认证密钥和账户地址。

使用私钥为该账户签署交易。

**认证密钥**

初始的账户地址设为在账户创建时生成的认证密钥。

认证密钥可以在生成新的公私钥对时更改，但账户地址不会改变。

Aptos支持多种认证方案，包括Ed25519、Secp256k1 ECDSA、K-of-N多重签名和多Ed25519方案（遗留方案）。

**多重签名与通用认证**

K-of-N多重签名：有N个签名者，至少K个签名用于认证交易。

通用认证：支持Ed25519和Secp256k1 ECDSA认证方案，允许多种密钥组合。

**密钥旋转**

Aptos账户可以通过account::rotate_authentication_key函数更换密钥，以防止已泄露的密钥被滥用。

**账户状态**

每个账户的状态由代码（Move模块）和数据（Move资源）组成。

Move模块：包含代码（如类型和过程声明），但不包含数据。

Move资源：包含数据，但不包含代码，表示区块链上的全局状态更新规则。

**访问控制与签名者**

在Aptos Move中，交易的发送者由signer表示。signer参数在Move模块的函数中用于访问控制，确保只有授权的账户才能执行某些操作。


### 2024.09.09


**费用组成**  

在Aptos区块链上，交易执行需要支付两部分费用：  

执行和IO成本：这部分费用用于支付交易的瞬时计算资源（如处理交易和在主网上的传播）。该费用以Gas Units（Gas单位）表示，价格会根据网络负载浮动。这部分Gas费用在交易执行后永久销毁。  

存储费用：这部分费用用于持久存储已验证的记录，以固定的APT价格表示，不会随网络负载而波动。存储费用在分配的存储空间被删除时可以退还，目前配置为退还整个生命周期内支付的存储费用。  

**Gas单位与价格**  

Gas单位：表示交易中消耗的瞬时资源的基本单位（如计算或存储访问）。  

Gas价格：用APT（Aptos原生代币）及其子单位Octas表示。总Gas消耗量取决于交易的复杂度。  

**费用明细**  

费用的详细信息通过0x1::transaction_fee::FeeStatement结构体表示，包含以下字段：  

total_charge_gas_units：总Gas费用  

execution_gas_units：执行Gas费用  

io_gas_units：IO Gas费用  

storage_fee_octas：存储费用  

storage_fee_refund_octas：存储费用退款  

**Gas费用与交易优先级**  

Aptos网络通过设置最低Gas单位价格来管理交易费用，市场决定了特定Gas价格的交易被处理的速度。  

提高Gas单位价格可以增加交易的优先级，但仅限于下一个区块的选择。  

在区块内，交易执行的顺序是由系统决定的，并基于交易随机化以提高并行执行效率。  

**交易中指定Gas费用**  

交易需要包含以下Gas字段：  

max_gas_amount：发送方愿意支付的最大Gas单位数。  

gas_price：每个Gas单位的价格，以Octas表示。  

如果消耗的总Gas数量超过max_gas_amount，交易将中止执行。

**存储费用和删除退款**  

存储费用：根据在全局状态中分配的新槽数量和现有槽的大小增长收取。 

存储删除退款：如果删除了状态项，当前配置为退还所有已支付的存储费用。  

**估算Gas消耗**  

可以通过链上模拟或本地使用Aptos CLI的Gas分析功能来估算交易的Gas消耗。结果是估计值，需在实际交易中留出安全余量。  

### 2024.09.10

在Aptos区块链上，链上状态以资源（resources）和模块（modules）进行组织，这些元素存储在各个账户中。这与其他区块链（例如以太坊）不同，在以太坊上，每个智能合约都有自己的存储空间。

**资源与实例的区别**

- 资源（Resources） 是具有key能力的结构体实例（struct instances），它们存储在全局存储或直接在账户中。

- 实例（Instances） 是由Move模块定义的结构体定义，可能包含key或store等能力。

- - key能力允许资源存储在全局存储或账户内。

- - store能力允许结构体实例存储在资源中。例如，CoinStore是一个包含APT代币的资源，而Coin是一个实例。

**定义资源和对象**

所有实例和资源都在一个模块中定义，并存储在一个地址下。例如：

- 0x1234::coin::Coin<0x1234::coin::SomeCoin> 表示在地址0x1234下的模块coin中定义的Coin结构体。

使用虚类型（phantom type）允许存在许多不同类型的CoinStore资源，每种资源具有不同的CoinType参数。

**实例（包括资源）的权限**

- 资源和其他实例的权限由定义结构体的模块决定。虽然可以访问并移除资源中的实例，但无法在未经模块许可的情况下更改实例的内部状态。

- 所有权则由资源存储在账户下或由定义结构体的模块逻辑决定。

**查看资源**

- 资源存储在账户中，可以通过在资源的完整查询路径中搜索拥有账户以及其地址和模块来定位资源。

- 资源可以在Aptos Explorer上查看或直接从全节点的API中获取。

**资源的存储方式**

- 定义结构体的模块指定了实例的存储方式。例如，存储代币的事件可以保存在接收账户或代币模块部署的账户中。

- 在单个用户账户中存储数据可以提高执行效率，因为不同账户之间的交易不会产生状态读写冲突，从而实现并行执行。

### 2024.09.11

Aptos 区块链数据的关键组成部分

**数据类型:**

交易（Transactions）: 表示由账户在区块链上执行的操作，例如资产转移。

状态（States）: 代表当前的账本状态，即所有已执行交易的结果，包括存储在资源中的值。

事件（Events）: 执行交易时生成的附加数据。

**交易（Transactions）:**

Aptos 交易包含发送者地址、认证信息、要执行的操作、所愿支付的 gas 费用等细节。

**交易状态：**

已提交并执行: 交易成功执行并记录在区块链上。

已提交但中止: 交易被记录但由于中止码而失败。

提交时被丢弃: 交易因 gas 不足、格式无效或密钥错误等原因未通过验证。

提交后被丢弃: 交易因超时或其他因素被丢弃。

所有已提交的交易将向发送者账户收取 gas 费用。

**交易内容:**

交易包含签名、发送者地址、公钥、有效载荷、gas 参数、序列号、过期时间等信息。

有效载荷类型：

入口点（Entry Point）: 直接调用特定函数。

脚本有效载荷（Script Payload）: 允许通过调用多个模块中的函数进行更复杂的操作。

**状态（States）:**

账本状态（全球状态）代表 Aptos 区块链上所有账户的状态。

交易通过生成输出（包括操作写入集和事件向量）来修改全球状态。

状态是版本化的，允许验证者跟踪状态变化并响应当前或过去账本状态的查询。

**证明和数据验证:**

Aptos 使用加密证明来验证数据的真实性。

区块链的数据在网络中复制，每次交易执行都会向梅克尔树（Merkle Tree）添加新的叶子，允许进行加密验证。

这些证明确保验证者对状态的共识，并允许客户端在不信任数据来源的情况下验证数据完整性。

**版本化数据库:**

使用无符号 64 位整数来跟踪账本状态的版本（系统执行的交易数量）。

允许在最新状态下执行交易，并提供历史账本数据。

**交易流程与状态变化:**

每个交易的执行遵循一个确定性函数（Apply()），确保状态转换的一致性。

### 2024.09.13

Move语言有两种类型的程序：模块（Modules）和脚本（Scripts）。模块是定义结构类型和操作这些类型的函数的库，而脚本是可执行的入口点，类似于传统语言中的main函数。

1. 模块（Modules）

定义：模块定义结构类型（struct）和操作这些类型的函数。结构类型定义了Move全局存储的模式，模块函数定义了更新存储的规则。

语法：模块的语法为：

```move
module <address>::<identifier> {
    (<use> | <friend> | <type> | <function> | <constant>)*
}
```

<address> 是有效的命名地址或字面地址。
   
内容：模块可以包含use（用于导入其他模块的类型）、friend（信任模块列表）、struct（结构类型）、function（函数）和constant（常量）等。

发布：模块会存储在全局存储中。

2. 脚本（Scripts）

定义：脚本是一个可执行的入口点，通常调用已发布模块的函数来执行对全局存储的更新。脚本是临时代码片段，不会存储在全局存储中。

语法：脚本的结构为：

```move
script {
    <use>*
    <constants>*
    fun <identifier><[type parameters: constraint]*>([identifier: type]*) <function_body>
}
```

脚本块必须从所有的use声明开始，然后是常量声明，最后是主函数的声明。

主函数可以有任意名称、参数数量，但不能返回值。

4. 命名地址

在源语言级别和编译期间可以使用命名地址（例如example_addr）。这些地址在字节码级别会被替换为实际的地址值。

命名地址允许在源代码中以更加语义化的方式管理模块地址。

5. 其他注意事项

模块名称通常以小写字母开头，并保存在相同名称的.move源文件中。

模块中的元素（use、friend、struct、function、constant）可以按任意顺序出现。

<!-- Content_END -->
